
Tue Dec 11 09:18:09 EST 2012

What are the next steps for HAMPI?

I think I should start simple. We have enough of an input language to ask some
interesting things. Start with that.

Don't worry about fix yet? Yes. I think that's right.

I should come up with a very simple HAMPI test, and get it to work in seri. We
can expand from there.

We'll need some inlining phase. Let me not worry about that.

Let me start by testing Nirav's solver, the simplest first, in Haskell. I need
a good test case...

With no fix. No intermediate vars. How about...

var x : 6
assert x in (ab)*

I expect to find: x is ababab.

1+ Write this as a .hmp file
2+ Run it in hampi, verify it does what I expect
3+ Encode the CFG in haskell
4+ Use Nirav's simplest solver to verify ababab is in it, and other things are
not.
5+ Port the CFG representation and Nirav's solver to seri, and do the same
test as (4)
6+ Write a query which makes a free string of length 6 and asserts it's in the
CFG in seri. Get this to work.
* this will need: support for free characters. Or some other representation for
  characters in the constraints and CFG.

Probably easiest to start using a different representation for chars in seri.
Use Bit #8. And I can change it later on to be Integer or whatever.

7. Implement the end-to end tool which reads from the .hmp file, passes to
seri, evaluates the result, returns it to haskell, and prints the result.

At this point we have a working tool, at least for simple things. Start adding
support for more features and implement more test cases.

Sounds like a plan to me.

Tue Dec 11 10:09:36 EST 2012

Nirav's naive implementation didn't work, and I thought I could make things
cleaner. So I just did my own RegEx. Simple data type and simple match
function. Let me use this to start.

It may end up being way too inefficient, but it's certainly nice and simple to
start.

Let me port it to seri, see how it goes.

In fact... it would be especially nice if I could keep it as seri and haskell
simultaneously...

That is... allow seri to recognize haskell files?

But that probably won't work out quite the way I want. What do I do?
Duplicate?

Reasons RegEx.hs will not work in seri currently:

* Explicit export list. I can ditch that of course...
* deriving of Show. I could add support for that in seri...
* list comprehension. I can write this a better way? Or support it in seri.
* pattern variables. I could add support for that in seri.

The rest should work just fine. Cool. I think this is a good start.

Let me look into adding the features necessary to make this work.

I could also allow seri to handle .hs files as input, so we can share the
definitions of things, as long as you are willing in haskell to restrict
yourself to certain features in the shared files (which I think is totally
reasonable).

Features desired for seri:
* explicit export list
* implicit import of prelude
* list comprehensions
* range things: [0..foo]
* pattern variable binding

Tue Dec 11 11:48:25 EST 2012

I managed to get everything but explicit export lists and list comprehensions
before getting tired of that. Let me remove those from RegEx and see if it
still works (it should).

Tue Dec 11 11:55:07 EST 2012

Okay, I think it should work in seri now. Let me give it a try...

Actually, we'll have a problem. We can't compare characters, can we...

That's annoying.

Shall I make it parameterized based on a notion of Char which has: Eq and Ord?
Or, rather, we just need Ord. That makes sense to me.

Let me do that in haskell first.

Tue Dec 11 12:04:12 EST 2012

Okay, so I parameterized it by the character type. Another feature that would
be nice to have: contexts for classes.

In order for this to work in seri, I need one of the following:
* make Char and instance of Ord
* implement ord :: Char -> Integer.

Regardless, it seems I need an Ord class. So do that. And add instances for
bit vectors and characters. I'll need this for HAMPI.

Tue Dec 11 13:07:49 EST 2012

I don't need ord just yet. We only need that for ranges. I changed atom to be
an arbitrary predicate on a single element.

This means I should be able to make Integer and Bit both work in seri for this
test case. Then go from there.

Okay! So I should be able to do this in seri now. I can use characters for the
initial test. That won't work for SMT... but it's something.

What I need for SMT is a way to convert a character to an Integer. I can add
that as a primitive.

First, let's try out char and see if it works. It ought to work just fine.

Tue Dec 11 13:17:13 EST 2012

Char works just fine. Good.

Now. I want to try out SMT. What I will need for this is...

ord.

As a primitive. Everything else is fine...

Actually, I can get rid of the prim_eq_Char if I have ord. I should do that in
seri.

Err... Just have a __prim_toInteger_Char. Use that.

Tue Dec 11 14:19:15 EST 2012

Okay! So, I need an end-to-end tool. Now that the basic stuff works.

I can start by assuming we don't need to do any inlining.

How does this work? How should it work?

Options:
* translate .hmp to .sri, run that.
Seri handles all the inlining stuff. We just have to translate.
Cost: we have to do this translation on all the inputs.
Thing is, it shouldn't matter how you express inputs, so long as they are not
significantly different, and they aren't here.
Cost: we have to at least read and typecheck the entire seri environment.

So, downside to this is: overhead to read and typecheck the entire
environment, and it doesn't seem quite fair unless we want to incorporate the
translation cost into the overall runtime.

* Generate a static query which takes arguments, compile with haskellf.
This is to avoid having to read in and type check prelude over and over again.

The idea is this: I generate using haskellf a function of the form:
    match :: S.CFG -> S.String -> S.Bool

When I parse in the CFG, I will inline it, do fix stuff, then convert to S.CFG
using seriEH.

Then I'll have a query... We need to convert assertions to queries... but we
can do that directly...

So, given the CFG, we get an S.CFG.
Now we are given the assertions. Using S.++, build up a S.String for the
argument, apply the S.String and S.CFG using the S.match function to build up
the assertions. Query the result, convert back to Haskell, then you are done.
  
This is the right way to go.
We don't have to read the environment or typecheck anything. We will construct
things well type checked. We do parsing as part of the problem.

Good. So I'll take this approach.

I can keep it parametric on the seri and haskellf sides.

So, what are the steps?

1. Compile the match function using haskellf, get the SERI_RegEx implementation.
2. Use this from a hard coded haskell thing for my test case.

This will work out the translations and things, so that should be fine.

Let me try it out.

Tue Dec 11 14:48:29 EST 2012

I'm shocked. Shocked that this actually seems to work. I can convert both a
string, and a RegEx into seri trivially. Awesome. Scary...

Anyway, what's the next step? Next step is to try a query.

Tue Dec 11 15:12:28 EST 2012

Problem with trying the query: the Atom function doesn't translate to seri. It
can't.

That makes sense. Sadness.

Well, it's fine if I don't specify Atom as a function. Instead make a tag.

What shall I call it?

Atom? Sure. Oh well...

Tue Dec 11 15:18:18 EST 2012

That fixed that. It's a little sad, but okay. Whatever.

Now then...

What's the next step?

The parser will generate for us a Hampi problem.

I want a function which is:

hampi :: Hampi -> IO ()

Which does everything. Make that work. Again, for this simplified test case.

For the simplified test case, what do we have?

Var ID Integer      -- the variable name and length.
Map ID RegEx        -- the variable ids.
[Assertion]         -- the list of assertions.

So, really what we want is...

var <- freevar n
mapM_ (doassert env) assertions
query var.

Hmm... Really what we will have is...

The RegEx inlines completely. So say I have as the assertion environment a map
from ID to completely inlined RegEx.

I have the free variable...

The real question is, what is an assertion?

The left hand side is a string type. The only way we can produce string types
is with var and val. These strings will be free, because they could contain
the var.

Okay. We can do the "contains" function easily enough... I hope. Let me not
worry about that for now.

Basically what we need for the assertions are a map from 
ID -> S.String
and 
ID -> RegEx

So, I should be able to write a function which is:

hampiquery :: Map ID S.String -> Map ID Reg -> [Assertion] -> Query ...

Umm... What if, instead what we do is...

We keep Val and RegEx separate. Then we want something like:

(Var ID Integer, Map ID Val, Map ID Reg, [Assertion]) -> Query (Answer String)

This function will create the free variable, then call something like:

(Map ID S.String, Map ID Reg, Assertion) -> Query ()

Which handles a single assertion. At this point, the String map contains fully
inlined symbolic values. Then this should be easy.

The question is... how do I go from (var ID Integer, Map ID Val) to Map ID
S.String? Perhaps with a tying the knot kind of thing. It can't be too bad.

Good. Let me write the code for this then. I'm sure I can make it work out.

Tue Dec 11 15:49:21 EST 2012

Okay, so I can handle "in" assertions now. I'm not going to worry about
contains assertions. Those will be easy to add when the time comes.

Next big question: Given the ID of the var, and the S.String for the var, and
all the vals: Map ID Val, how do I generate Map ID S.String?

How about this. It's easy. I just have to have a function:

(ID, S.String, Map ID Val) -> ID -> S.String

Which looks up the fully inlined value of the given ID.

Now it's easy to create the new map:

 Map.fromList [f x | id <- varid : keys m], or some such.

Okay. I can do this next. First question: what does Var look like?

Var = ID | String | Concat Var Var

So we can do this recursively easily enough.

Tue Dec 11 16:15:31 EST 2012

Okay! So I have the vals conversion. I'll assume the RegEx conversion to
start. Which means we have one last thing.

hampi :: Hampi -> Query (Answer [Elem])

Should be trivial now.

Tue Dec 11 16:26:01 EST 2012

Okay! So we have a query going. What things are left to do?

* Print the output in the right format.
* Parse the Hampi spec from file.

After that it's just a matter of adding features...

I should clean up the code and reorganize too... Perhaps before I do the
parser? Or does it not matter?

The job of the parser is simple. String -> Maybe Hampi.

Do I need to have things be parametric? We never want to do two different
versions in the same code, so I ought to do a typedef. I bet that cleans
things up nicely...

Except we have to keep the typedefs aligned between haskell and seri? No. It
should make sense. It's the difference between: Elem Foo and S.Elem S.Foo

Okay, I can do that first. Just use a typedef for Elem type. How about: RChar
and RString? Sounds good to me.

Oh. One thing to note: we don't preserve type synonyms in the translate to
haskell. That's annoying.

Oh well. Whatever.

Tue Dec 11 16:40:58 EST 2012

Okay, so let me generate the right output next, which is easy enough to do.

Tue Dec 11 16:48:28 EST 2012

That's done. All that's left is the parser. This should be pretty easy.

First, organization:

RegEx.hs, RegEx.sri -- as is
Hampi.hs -- defines Hampi datatype (fixed Char type)
Lexer, Parser -- build up Hampi datatype
hampi.hs -- main program. Imports rest, does query stuff.

I can start by pulling the Hampi stuff out of test.hs.

Done. Next step: just update the parser to use the Hampi spec as is...

Stub out all the unsupported stuff to start.

Tue Dec 11 17:25:02 EST 2012

Okay! We have a hampi executable now, start to finish. It's just lacking in
features.

So... let's add us some features.

I would like to start with pure regex tests. Should I write my own? Can I find
some in the hampy distribution?

Let me try writing my own, see what we get. I can run them on both my hampi
and the real hampi and compare the outputs. Cool.

