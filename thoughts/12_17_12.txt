
Mon Dec 17 14:23:58 EST 2012

I implemented the state monad in seri. Rather than implement map, let me start
with an association list, and see if I can make that work?

There are a few concerns here.

* is porting from haskell to seri correct?
* is the new algorithm for match correct?
* are there issues with the map implementation in seri?

If I jump all at once, it may not be clear what is or is not important.

So I should go a step at a time. What order should the steps be in?

How about this:

1. Change 'fix' to use an association list in the haskell implementation. See
how much worse the performance is, verify it still works.

2. Convert haskell implementation to be in seri form. Verify it still works.

3. Move ...

I don't know. Porting all over to seri concerns me. What if, instead, we try
the sharing implementation all in haskell, see how well it works, if at all?
Then port over to seri. 

I like that idea. It shouldn't be too hard, right? Just replace fixN with
match, and have match work on symbolic booleans. Yes. Good. Let me try it out
then.

Um... no, it's rather messy. And there are concerns about laziness and what
have you. It's just rather annoying.

Let me do (1), (2), (3), all in seri first, then push match into seri. I think
that's more likely to work.

Mon Dec 17 15:07:16 EST 2012

I did (1). In some cases we get an order of magnitude performance
degradations. In others it's all over the place. I'll leave it for now, but I
think this will be an important performance optimization to support in the
near future.

Next step: switch to syntax supported by seri in Fix.hs.

Um... it may be better if I remove the polymorphism in RegEx. We don't really
need that, do we?

Ug! I don't know. I don't know what to do. I'm so scattered now.

Let me try to make more clear what it is I'm trying to do.

First and foremost... I'm trying to reduce an exponential complexity in some
specific queries by sharing submatches.

To do this, I want to move computation into seri, because it's much cleaner
and easier to work with.

So I want to do that in small steps.

The first step was switch to a supported Map implementation. I've done that.
It's not the most efficient, but it should be efficient enough to show the
improvement I want. If not, I can improve it later.

The next step is to try porting the fixN function to seri, because it's
basically what the match function will look like, only I know fixN is correct,
and I can get a sense of the cost of moving it from haskell to seri.

What do I need to convert it to seri?

* seri must know about CFG, Elem
* stop using pattern guards, or support those in seri.

If seri knows about CFG and Elem, there's no reason for RegEx to be
polymorphic. Let me start by hardcoding Elem as Integer, make that work. That
will make it easier to convert CFG to seri.

Okay. That's done. What's the next step?

Move all the RegEx stuff to SeriRegEx, I suppose.

Okay, I have all the RegEx stuff there now. That's good.

Next thing I need: CFG. Just the structure. Not the constructors.

Okay! So all the headers for Fix are ported to seri. Let me just try compiling
Fix in seri.

Expected problems:
* export all
* Data.Functor needed in seri library.
* pattern guards for fixM (how hard to add support for in seri?)

Now fix compiles in seri. That's good. Should be trivial to switch to the seri
implementation of fix then. Let's give it a shot.

Mon Dec 17 16:10:47 EST 2012

Switched over to seri for fix. Problem: we seem to get stuck in an infinite
typeof loop?

Why?

How do I figure this out?

Okay, so here's the deal. typeof is being called way more often than it ought
to be. Why? It's from caseEH.

In __caseTuple2__... I bet it's the tuple issue. Let me fix that.

Because we are converting tuple2s.

The fix is: define tuple2 as a primitive in Prelude.

Mon Dec 17 16:41:40 EST 2012

I changed seri, but I haven't tried it yet. To see if my fix worked, try the
following:

1. reinstall seri
2. try running shampi tests again.
