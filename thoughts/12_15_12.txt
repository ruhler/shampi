
Sat Dec 15 10:09:02 EST 2012

Okay, so this is easy. I've got it all figured out.

Basically we morph the fixN function to the match function. Cache submatch
results, and put the whole thing in seri.

The first thing to try is a pure haskell version?

The first thing to try is writing up a pure haskell version. See what things I
use. I suspect I'll want State monad and Map. See how I could implement those
in seri.

The (new) match function will take the following:

State:
  fs_cfgs :: Map.Map ID CFG
  fs_cache :: Map.Map (ID, Integer, Integer) Bool

In other words, we have the CFGs, and we have the map from ID, length, and
offset in the string being matched against to Bool value of whether it matches
or not. So, things like:

E2.0 = False
E2.1 = False
etc...

The fixid function takes the following arguments:

ID, Integer, Integer, String.

The string is the part of the full string being matched at the given offset.

For example, this could be:

match E2.2 "()()"

When matching:

E6.0 "()()()"

The fix function will take: CFG , Integer, Integer, String, and return a
boolean.

Everything else is the same as the current fix implementation. Easy.

Let me try coding it up (in haskell).

Sat Dec 15 10:31:38 EST 2012

I implemented it. The new match function rough draft. There's nothing hard
about it. It combines fix and match, and caches everything I want to cache.

What do I need to make it work in seri?

* state monad
* (<$>)
* fromMaybe
* Data.Map
* pattern guards (could be translated to case statement.

That's it! The rest is easy.

So, everything I'm confident I can do except for Map. let me see how they
implement Map, get a sense of how hard it would be to port.

We also have namespace issues with map, I'll probably want to write my own
local one.

Sat Dec 15 10:42:08 EST 2012

Looks like the haskell implementation of Map is a balanced binary tree. They
keep explicit size information, and upon insertion rebalance the tree based on
some ratios.

It would not be hard to implement a simple version of this for what we want.

Cool. That's what all I should do next.


