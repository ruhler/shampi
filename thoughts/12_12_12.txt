
Wed Dec 12 09:11:23 EST 2012

I want to add character ranges again. Question is, how should this be done?

I think it should be a separate kind of an atom. Call it a Range.

For this to work, I'll need an Ord class in seri. Which means I want to rename
the primitives (<) and (>) to something specific to integer.

For now the Ord class can just have those operations: <, >, <=, >=. Don't
worry about requiring Eq. Even if it doesn't match haskell, it's still closer
than currently.

So, this is easy:

1. Change (<) and (>) to be Ord in seri
2. Add RangeR ... err... it's really a kind of atomic predicate. Don't worry
about it. Add RangeR. That's fine.

Then we should be good.

Wed Dec 12 09:38:42 EST 2012

Next step: the contains assertion.

I need a seri function, in SeriGen: contains :: String -> String -> Bool.

I can do it using the isPrefixOf thing?

Oh, it's easy:

isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)

isPrefixOf [] _ = True
isPrefixOf _ [] = False
isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys

tails xs = xs : case xs of
                    [] -> []
                    _ : xs' -> tails xs'

Or something like that. Easy enough to do. I'll put it in Data.List in seri.

Wed Dec 12 10:31:18 EST 2012

Good, making progress. What features are left?

* character escapes
* reg id
* reg fix
* cfgs

In other words... we're very close to functional completion.
I imagine we'll run into performance issues with generate SMT queries that
will want to fix, or in generating the SMT queries. But that's to deal with
another time, after after we can already run the benchmarks correctly.

Let me approximate character escapes. I don't really understand how they are
supposed to work, but I can get close, just to knock that off the list.

Wed Dec 12 10:37:07 EST 2012

Char escapes don't make any sense and appear not to work in the original hampi
anyway, so let me not worry about those. All that's left:

* reg id
* reg fix
* cfgs

What's the idea? Let's start with reg id. It's like val things. We want an
inline phase:

Map ID RegEx -> Map ID RegEx

You give an input map, it gives you back the fully inlined map. Easy.

I worry about fix. But let's not worry about that yet. Focus on reg id
inlining.

1. We need to move the definition of ID to RegEx. That's fine.
2. Add this inline phase when we call mkhampi in the parser?
Sure. Seems reasonable. Or... better yet, in the main function.
So add to Hampi.hs: inlineregs :: Hampi -> Hampi

That's all we should need.

Wed Dec 12 10:47:19 EST 2012

Trouble... we really will want an infinite looped inlining phase.

Well, that's for fix. We don't need it yet. So I got reg ids working without
that. Now we are on to fix...

How does fix work? Is it bad to create an infinite RegEx?

I could certainly see it being annoying, but ...

I suppose the real question is, is it possible, if you have a finite input
string and an infinite RegEx, that you never finish checking a match?

If so, my approach isn't going to work, and I'll need to find another. It's
worth thinking about and understanding before attempting.

E = "()" | E E | "(" E ")"

Try to match against the string: "????"

What do I get?

or checks against any, so let's see...

"()" - fails. length is wrong.
E E - loops! We start recursing! This approach is not going to work!

Bugger. I should talk to Nirav and see what progress, if any, he has made.

Can we assume a cfg always matches at least one character? That would make
this doable...

Wed Dec 12 11:14:13 EST 2012

We can't assume that. Consider this case, which hampi handles just fine:

A = "" | "x" | A A

With a fixed length string.

Matching "????"
 "" - nope
 "x" - nope
 ("", "????") - first matches. Second: infinite recursion!
 ("?", "???")
 ("??", "??")
 ("???", "?")
 ("????", "")

Well, here's an idea. Let's say cat never tries the first one, to make sure we
reduce the match in size each time. Could that be a violation of something?

Try:

B = ""
C = "xxxx"
A = B C

Wed Dec 12 11:30:51 EST 2012

Okay, so the idea is this. We need to get rid of any epsilons. If we can do
that, we get the guarantee we need, I can do full inlining, then we are happy.

How do we get rid of epsilons? It's described in Sipser's book.

1. remove epsilon rules. For example, in the above, we remove 'B'.
2. For every occurrence of a removed rule, add a new rule with the occurrence
deleted.

For example: A = B C ==> A = C
             A = A B C B D
                ==> A C B D ==> ACD
                ==> A B C D ==> ACD
3. Given a rule R -> A, add R -> epsilon unless we already removed that rule.
Repeat until we eliminate all epsilon rules.

That should be enough.

Um... Can I come up with some more-systematic way to understand this?

Oh. It's not that bad. I just explained it poorly.

Idea is:
1. identify a rule A -> x | y | e
 which contains an epsilon, call it e
2. For any rule in which A is used, add alternatives where A is replaced with
  'e'
 for example:  B -> AB | BC | CAB
  turns into:  B -> AB | BC | CAB | B | BC | CB

And that's it. Rinse and repeat. There may be a loop condition I have to check
for too.

Ug. This is going to be non-trivial.

But! You know what I can do for now? Assume we've already done the
transformation. Hurray! Then come back and do the transformation later.

So, basically, try it out and see what happens. Just don't have any tests for
blowing up.

Sounds good to me.

Wed Dec 12 12:04:00 EST 2012

Nope. It doesn't work. I have to solve this. Bugger.

Wed Dec 12 13:10:42 EST 2012

Question. Why does the following not work:

E := "()" | E E | "(" E ")" ?

It does not have any epsilons. So, it's not an issue with removing epsilons.
It's something else. Something else I have to solve before removing epsilons.

I know the problem with this.

match E "????"

Asks: do we match any of the alternatives for E?

Check: "()" - no.
Check: E E - asks: match E "????"
 Which is infinitely recursive.

So, how do we get around it?

The idea was, let's assume that an alternative much match at least something.
That is, assume we have no epsilons. I believe this is a fair assumption to
make... but I'll have to check regular expressions, otherwise it's clear...

Oh. No. It's not a fair assumption to make. Because of the star operator,
which may have an epsilon. So that approach is not allowed.

Okay... fine... so what if we assume the answer is no whenever we find ourself
asking a recursive question?

Hmm... Well.. ug.

Hmm...

You know what? I could get all the syntax going for cfgs before worrying about
this issue. Just don't have any recursive calls. That sounds like a plan to
me.

Wed Dec 12 13:25:51 EST 2012

Okay, good. I'm in a place where I can work on the syntax. The 'fix' operation
doesn't work yet. I'll come back to that later.

Wed Dec 12 13:59:44 EST 2012

All that's left now is the fix operator. Let me try to come up with a brute
force solution. Anything, to see if I can make it work.

I'll work on paper for a bit.

Wed Dec 12 14:20:39 EST 2012

Okay, I have a proposal. Let me start with the concrete example.

E := "()" | E E | "(" E ")"

The trick is, we will do dynamic programming.

Let E# represent fix(E, #).

Say the goal is to produce E4. We will start from the bottom.

E0 := {}
 Look at all the options.
 1. "()", which is: concat '('  ')'
    For concat, we build up all the strict partitions of the number.
    In this case, there are none for 0, so we have nothing here.
 2. E E - again, it's a concat, so same deal
 3. "(" E ")" - again, concats, so same deal.
 Thus, E0 is Empty - it matches nothing.

E1 := {}
 1. "()" - again, no way to partition
 2. ditto
 3. ditto

E2 := "()"
 1. "()" - can be partitioned one way:
    fix 1 "(", fix 1 ")". So we have an option: "()".
 2. E E - can be partitioned one way:
        E1 E1 - but those are empty, so no choices here.
 3. "(" E ")" - no possible.

E3 := {}
 1. none to add.
 2. E1 E2... none to add
 3. "(" E1 ")" ... none to add

E4 := E2 E2 | "(" E2 ")"
 1. none to add.
 2. E2 E2 adds
 3. "(" E2 ")" adds.

And there you have it. We can continue a little more for the fun of it.

E5 := {} 

E6 := E2 E4 | E4 E2 | "(" E4 ")"

E8 := E2 E6 | E6 E2 | "(" E6 ")"

And so on.

What's important here?

* we make labels for smaller things, so we can hopefully preserve sharing that
  way.
* fix(x, n) will be a list of options which could be empty. List monad looks
  potentially useful here.

Okay. Sounds good. But what about epsilons?

There are two places we could find epsilons.
1. As an alternative: then it becomes an E0. That's fine.
2. As a concat: won't ever happen, so no need to worry about it.

Question. How do we deal with star?

Note: we shouldn't end up with any internal fixes... I don't think. Not that
it really matters any...

E := "()" | E* | "(" E ")"

Well, again, we don't look at fix 0, so consider E* to be:
    E E*

Then match against the E and E* as smaller entities. No problem with that at
all.

I think this is it then.
 
That's it. That's how we can convert bounded CFG to a regular expression.

Nirav says he's going to do this. Fine. I'll let him do it then.

Wed Dec 12 15:08:11 EST 2012

Tried out on all the hampi test cases. We have the following issues:

* fix support (known issue)
* substring vals: val x := f[4:2]
* equals assertions: assert x equals y;
    I assume the same as contains only using equality.
* bound inference: some things don't put 'fix'...
    Who knows how to deal with that? Let's get fix working first.

That all is easy enough.

Let me add the little things, because they are easy enough.

First. equals.

No. I don't know how it works. I should focus on the benchmarks first.

Let me try to run the hampi benchmarks. Figure out where they are and such.

Wed Dec 12 16:22:00 EST 2012

Integrated Nirav's fix thing:

* cfgopt fails, because it doesn't compute OC2 before E2. Not sure how to fix.

Wed Dec 12 16:34:01 EST 2012

* paper fails... It's spending all it's time in fromExpH.
Why? Is it a really complicated expression? Is it an infinite loop?
Can I simplify the grammar somehow? What's up?

Wed Dec 12 16:35:53 EST 2012

Well, one problem is: we don't call fix. Let me fix that.

Wed Dec 12 16:55:25 EST 2012

Problem is: contains blows up exponentially based on the size of the thing
being contained. That's a seri performance problem to work out.

I'll think about it and get back to you.

