
Wed Dec 19 09:12:03 EST 2012

Idea:
* I don't need to insert False in match to break recursion, because fix
  already breaks recursion.

That should help improve performance a bit.

First step: let's see where we are at, now that I've improve the case
desugaring in seri.

Wed Dec 19 09:26:58 EST 2012

Good news. Changing the case desugar made a huge difference. Like 3x
improvement.

Now, what's the next step?

We spend lots of time in...
* __mkTuple2__
* ==
* bind and casing on State

My suspicion: Ord for map_lookup is expensive. It makes a couple tuples (which
is why we have so much __mkTuple2__), it calls ==. That's the primary thing.
The secondary thing is... state monad is slow.

Wed Dec 19 09:55:12 EST 2012

Concern: My profiling numbers are misleading. For instance __caseFoo includes
numbers for evaluating the arguments. Not just the cost of doing the case to
figure out which body to use. That's misleading. I think the same with the
state monad.

If I really want good numbers, I need to annotate the SeriGen.hs code by hand,
butting SCC's where I want them.

I think we'll find map_lookup still dominates the time.

Wed Dec 19 10:14:20 EST 2012

map_lookup doesn't totally dominate the time. But it's still a good chunk:
40%. So it's still worth making it faster.

Ways to make it faster:
* Auto derive ord, and use compare function instead of (<) and (==).
* Make the tree balanced, as in Data.Map.

Making the tree balanced is easier. So let me try that first. I just have to
copy code from Data.Map and hope it work right.

How about this: I'll trust it keeps things balanced, and I'll just double
check it produces a correct tree. Fair enough? Good.

Wed Dec 19 11:06:56 EST 2012

Implemented map...

There's something funny going on. Why does buggy/perf.hmp blowup with size 8?

Let's look at the complexity we are talking about here:
* FixN regs produces:
    E2, E4, E6, E8 only.
* MatchN can at most enter 4*8 = 32 entries in the map.
    That should take no time at all!

So there must be a bug. There must be.

Let me do the following. Let me look at what's going on.
Let me print out regs, verify it looks right.
Let me print out every time I'm about to look something up in the cache.

Verify it looks like it should.

For me to do this, I want the "trace" primitive added to seri.

[((['E'], 0), ∅), ((['E'], 1), ∅), ((['E'], 2), 40 41), ((['E'], 3), ∅),
((['E'], 4), (E E | 40 E 41)), ((['E'], 5), ∅), ((['E'], 6), (E E | (E E | 40
E 41))), ((['E'], 7), ∅), ((['E'], 8), (E E | (E E | (E E | 40 E 41))))]

What we get is:

E0 := {}
E1 := {}
E2 := "()"
E3 := {}
E4 := (E2 E2 | "(" E2 ")")
E5 := {}
E6 := (E2 E4 | (E4 E2 | "(" E4 ")"))
E7 := {}
E8 := (E2 E6 | (E4 E4 | (E6 E2 | "(" E6 ")")))

Exactly as expected and desired.

Let me make the following changes, just to clarify things:
1. show Regex should add ".#" for the length of a variable, to be clear.
2. Filter out Empty regexs from the map.

[((['E'], 2), 40 41), ((['E'], 4), (E.2 E.2 | 40 E.2 41)), ((['E'], 6), (E.2
E.4 | (E.4 E.2 | 40 E.4 41))), ((['E'], 8), (E.2 E.6 | (E.4 E.4 | (E.6 E.2 |
40 E.6 41))))]

E2 := "()"
E4 := (E2 E2 | "(" E2 ")"
E6 := (E2 E4 | (E4 E2 | "(" E4 ")"))
E8 := (E2 E6 | (E4 E4 | (E6 E2 | "(" E6 ")")))

Exactly as expected and desired. Good.

Now... let's see what all things we are getting and putting into the cache...

Okay... how does it look then...

It starts out okay... But get's stuck somehow. Something funny is going on...

How about I trace through by hand and see what I get that way?

The top level regex is presumable E8? Or the value of E8. That makes sense.
So I expect the following:

E2.0 needed
E2.0 updated

...

I need to be careful here... I'm being explicitly lazy. But... the trouble
is... what if I don't know the result of a match? Then I don't know what to do
next. The argument to bind becomes symbolic, and I start forking off different
approaches.

How about, don't be explicitly lazy. We need to look at the whole thing
anyway, but it should be quick, with a small cache... That way we build up
symbolic predicates entirely concretely.

I can try that...

There. So what I'm trying now is, the control flow does not depend at all on
the intermediate match results. So the matchM algorithm is entirely concrete,
it just produces symbolic values.

We may end up doing more work than we have to, but because we are caching
things, we are doing dynamic programming. Worst case I expect quadratic in the
length of the thing being matched, as opposed to exponential.

Yup! That was it. Cool... Let me remove trace, see how things stand now.

That was definitely the issue.

I'll run the benchmarks, get an overall sense, and go from there.

Wed Dec 19 13:22:55 EST 2012

Okay! Things are much improved. But... now we have the problem that the
generated SMT queries are exponential. Everything is quadratic except for
that.

It could be quadratic if we preserved sharing in seri. So that's the next
task. Figure out how to preserve sharing in seri.

Wish me luck.

Oh, I should verify identify actually does what I expect. If I run into bugs,
check that first.

I have my share test I can try out I suppose. And I trust my other tests.

Next step: add ID to complex expressions, make sure we allocate new ID's and
that elaboration still works. To start with, we won't touch these ID's
anywhere.

Thu Dec 20 11:40:25 EST 2012

Starting with paper example...

I want to make sure I get the right profiling information. Let me specially
annotate the things I'm interested in.

Where could the time be coming from?

fix
match
 lookup_regs
 lookup_cfgs
fromExpH
check

Note: paper example runs into stack overflow. What's taking up so much stack?

Let me turn on some interesting SCCs in seri. Particularly with share. And see
what kind of profile we are looking at then.

