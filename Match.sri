
module Match where

import Control.Monad.State

import Data.Functor
import Data.Maybe
import Map

import SeriRegEx
import SeriCFG

data SubMatch = SubMatch {
    m_id :: ID,         -- ID.
    m_len :: Integer,   -- Length to match.
    m_off :: Integer    -- Offset in entire string to match at.
} deriving (Eq)

instance Ord SubMatch where
    (<) (SubMatch ax al ao) (SubMatch bx bl bo)
        = (ao, (al, ax)) < (bo, (bl, bx))
    (>) a b = not (a <= b)
    (<=) a b = (a < b) || (a == b)
    (>=) a b = not (a < b)

data MS = MS {
    ms_regs :: Map (ID, Integer) RegEx,
    ms_cache :: Map SubMatch Bool
}

type MatchM = State MS

matchidM :: SubMatch -> ElemString -> MatchM Bool
matchidM s@(SubMatch x n off) str = do
    ms <- get
    case map_lookup s (ms_cache ms) of
        Just v -> return v
        Nothing -> do
            put $ ms { ms_cache = map_insert s False (ms_cache ms) }
            let r = fromMaybe Empty $ map_lookup (x, n) (ms_regs ms)
            v <- matchM r off str
            modify $ \ms -> ms { ms_cache = map_insert s v (ms_cache ms) }
            return v

matchM :: RegEx -> Integer -> ElemString -> MatchM Bool
matchM r off str =
  case r of
     Epsilon -> return True
     Empty -> return False
     Atom c -> return (head str == c)
     Range a b -> return ((a <= head str) && (head str <= b))
     Concat _ a b -> do
       let i = rlength a
       a' <- matchM a off str
       if a'
          then matchM b (off+i) (drop i str)
          else return False
     Or _ a b -> do
         a' <- matchM a off str
         if a'
            then return True
            else matchM b off str
     Variable n id -> matchidM (SubMatch id n off) str

match :: Map (ID, Integer) RegEx -> RegEx -> ElemString -> Bool
match regs x str = evalState (matchM x 0 str) $ MS regs map_empty

