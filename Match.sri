
module Match where

import Debug.Trace

import Control.Monad.State

import Data.Functor
import Data.Maybe
import Map

import SeriRegEx

data SubMatch = SubMatch {
    m_id :: RID,        -- ID.
    m_len :: Integer,   -- Length to match.
    m_off :: Integer    -- Offset in entire string to match at.
} deriving (Eq)

instance Show SubMatch where
    show (SubMatch x n o) = show x ++ "." ++ show n ++ "." ++ show o

instance Ord SubMatch where
    compare (SubMatch a b c) (SubMatch d e f)
      = __lexorder [compare a d, compare b e, compare c f]
        
    (<) a b = compare a b == LT
    (>) a b = compare a b == GT
    (<=) a b = compare a b /= GT
    (>=) a b = compare a b /= LT

type MatchCache = Map SubMatch Bool

mc_empty :: MatchCache
mc_empty = map_empty

mc_lookup :: SubMatch -> MatchCache -> Maybe Bool
mc_lookup = map_lookup

mc_insert :: SubMatch -> Bool -> MatchCache -> MatchCache
mc_insert = map_insert

data MS = MS {
    ms_regs :: Map (RID, Integer) RegEx,
    ms_cache :: MatchCache
}

type MatchM = State MS

matchidM :: SubMatch -> ElemString -> MatchM Bool
matchidM s@(SubMatch x n off) str = do
    ms <- get
    case mc_lookup s (ms_cache ms) of
        Just v -> return v
        Nothing -> do
            let r = fromMaybe Empty $ map_lookup (x, n) (ms_regs ms)
            v <- matchM r off str
            modify $ \ms -> ms { ms_cache = mc_insert s v (ms_cache ms) }
            return v

matchM :: RegEx -> Integer -> ElemString -> MatchM Bool
matchM r off str =
  case r of
     Epsilon -> return True
     Empty -> return False
     Atom c -> return (head str == c)
     Range a b -> return ((a <= head str) && (head str <= b))
     Concat _ a b -> do
       let i = rlength a
       a' <- matchM a off str
       b' <- matchM b (off+i) (drop i str)
       return (a' && b')
     Or _ a b -> do
         a' <- matchM a off str
         b' <- matchM b off str
         return (a' || b')
     Variable n id -> matchidM (SubMatch id n off) str

match :: Map (RID, Integer) RegEx -> RegEx -> ElemString -> Bool
match regs x str = evalState (matchM x 0 str) $ MS regs mc_empty

