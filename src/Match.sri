
module Match where

import Debug.Trace

import Control.Monad.State

import Data.Functor
import Data.Maybe
import Map

import Elem
import RegEx

data SubMatch = SubMatch {
    m_id :: RID,        -- ID.
    m_len :: Integer,   -- Length to match.
    m_off :: Integer    -- Offset in entire string to match at.
} deriving (Eq)

instance Show SubMatch where
    show (SubMatch x n o) = show x ++ "." ++ show n ++ "." ++ show o

-- RID -> Length -> Offset -> Match Result
type MatchCache = Map RID (Map Integer (Map Integer Bool))

mc_empty :: MatchCache
mc_empty = map_empty

mc_lookup :: SubMatch -> MatchCache -> Maybe Bool
mc_lookup (SubMatch rid len off) mrid = do
    mlen <- map_lookup rid mrid
    moff <- map_lookup len mlen
    map_lookup off moff

mc_insert :: SubMatch -> Bool -> MatchCache -> MatchCache
mc_insert (SubMatch rid len off) v mrid =
  let mlen = fromMaybe map_empty (map_lookup rid mrid)
      moff = fromMaybe map_empty (map_lookup len mlen)
      moff' = map_insert off v moff
      mlen' = map_insert len moff' mlen
  in map_insert rid mlen' mrid
    

data MS = MS {
    ms_regs :: Map (RID, Integer) RegEx,
    ms_cache :: MatchCache
}

type MatchM = State MS

matchidM :: (Element e, Eq e, Ord e) => SubMatch -> [e] -> MatchM Bool
matchidM s@(SubMatch x n off) str = do
    ms <- get
    case mc_lookup s (ms_cache ms) of
        Just v -> return v
        Nothing -> do
            let r = fromMaybe Empty $ map_lookup (x, n) (ms_regs ms)
            v <- matchM r off str
            modify $ \ms -> ms { ms_cache = mc_insert s v (ms_cache ms) }
            return v

matchM :: (Element e, Eq e, Ord e) => RegEx -> Integer -> [e] -> MatchM Bool
matchM r off str =
  case r of
     Epsilon -> return True
     Empty -> return False
     Atom c -> return (head str == toElem c)
     Range a b -> return ((toElem a <= head str) && (head str <= toElem b))
     Concat _ a b -> do
       let i = rlength a
       a' <- matchM a off str
       b' <- matchM b (off+i) (drop i str)
       return (a' && b')
     Or _ a b -> do
         a' <- matchM a off str
         b' <- matchM b off str
         return (a' || b')
     Variable n id -> matchidM (SubMatch id n off) str

match :: (Element e, Eq e, Ord e) => Map (RID, Integer) RegEx -> RegEx -> [e] -> Bool
match regs x str = evalState (matchM x 0 str) $ MS regs mc_empty

